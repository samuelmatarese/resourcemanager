import type { TextDocument } from "vscode";
import * as fs from "fs";
import * as path from "path";
import { XmlHelper } from "./xmlHelper";
import { AccessibilityType } from "../../webview/events/accessibility/accessibilityType";
import * as vscode from "vscode";
import { AccessibilityTypeMapper } from "../designer/accessibilityTypeMapper";

export class DesignerHelper {
  public static GenerateDesignerFile(document: TextDocument) {
    const accessability = XmlHelper.checkAccessability(document);
    let name = document.fileName;
    name = name.substring(0, name.lastIndexOf(".")) + ".Designer.cs";

    if (accessability !== AccessibilityType.None) {
      let fileContent = this.GenerateDefaultText(this.deriveNamespace(document), path.basename(document.fileName, path.extname(document.fileName)), accessability ?? AccessibilityType.Internal);
      fileContent = fileContent + XmlHelper.getDesignerText(document, accessability ?? AccessibilityType.Internal);
      fs.writeFile(name, fileContent, () => {});
    } else {
      fs.unlink(name, () => {});
    }
  }

  private static deriveNamespace(document: TextDocument): string {
    const projectRoot = this.findProjectRoot(path.dirname(document.fileName));

    if (!projectRoot) {
      return "DefaultNamespace";
    }

    const relativePath = path.relative(projectRoot, path.dirname(document.fileName));
    const namespaceParts = relativePath.split(path.sep).filter((part) => part && /^[a-zA-Z0-9_]+$/.test(part));
    const projectName = path.basename(projectRoot);

    return [projectName, ...namespaceParts].join(".");
  }

  private static findProjectRoot(startPath: string): string | null {
    let current = startPath;
    while (true) {
      const csprojFiles = fs.readdirSync(current).filter((file) => file.endsWith(".csproj"));
      if (csprojFiles.length > 0) {
        return current;
      }

      const parent = path.dirname(current);
      if (parent === current) {
        return null;
      }
      current = parent;
    }
  }

  private static GenerateDefaultText(namespace: string, fileName: string, accessabilityType: AccessibilityType) {
    return `//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the RESX Manager tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ${namespace} {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    ${AccessibilityTypeMapper.MapToText(accessabilityType)} class ${fileName} {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        ${AccessibilityTypeMapper.MapToText(accessabilityType)} ${fileName}() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        ${AccessibilityTypeMapper.MapToText(accessabilityType)} static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    var temp = new global::System.Resources.ResourceManager("${namespace}.${fileName}", typeof(${fileName}).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        ${AccessibilityTypeMapper.MapToText(accessabilityType)} static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }`;
  }
}
