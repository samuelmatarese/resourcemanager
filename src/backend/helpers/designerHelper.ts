import type { TextDocument } from "vscode";
import * as fs from "fs";
import * as path from "path";
import { XmlHelper } from "./xmlHelper";
import { AccessabilityType } from "../designer/accessabilityType";
import * as vscode from "vscode";
import { AccessabilityTypeMapper } from "../designer/accessabilityTypeMapper";

export class DesignerHelper {
  public static GenerateDesignerFile(document: TextDocument) {
    let name = document.fileName;
    name = name.substring(0, name.lastIndexOf(".")) + ".Designer.cs";
    let fileContent = this.GenerateDefaultText(this.deriveNamespace(document), path.basename(document.fileName, path.extname(document.fileName)), AccessabilityType.Internal);
    fileContent = fileContent + XmlHelper.getDesignerText(document, AccessabilityType.Internal);
    fs.writeFile(name, fileContent, () => {});
  }

  private static deriveNamespace(document: TextDocument): string {
    const workspaceFolder = vscode.workspace.getWorkspaceFolder(document.uri);

    if (!workspaceFolder) {
      return "DefaultNamespace";
    }

    const relativePath = path.relative(workspaceFolder.uri.fsPath, path.dirname(document.fileName));
    const namespaceParts = relativePath.split(path.sep).filter((part) => part && /^[a-zA-Z0-9_]+$/.test(part));
    const projectName = path.basename(workspaceFolder.uri.fsPath);

    return [projectName, ...namespaceParts].join(".");
  }

  private static GenerateDefaultText(namespace: string, fileName: string, accessabilityType: AccessabilityType) {
    return `//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the RESX Manager tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ${namespace} {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    ${AccessabilityTypeMapper.MapToText(accessabilityType)} class ${fileName} {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        ${AccessabilityTypeMapper.MapToText(accessabilityType)} ${fileName}() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        ${AccessabilityTypeMapper.MapToText(accessabilityType)} static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    var temp = new global::System.Resources.ResourceManager("${namespace}.${fileName}", typeof(${fileName}).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        ${AccessabilityTypeMapper.MapToText(accessabilityType)} static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }`;
  }
}
